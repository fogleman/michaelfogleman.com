{% extends 'base.html' %}

{% block content %}

{% filter markdown %}

### Craft

<p class="lead">
    Craft is a Minecraft clone for Windows, Mac OS X and Linux. It is written
    in just a few thousand lines of C and uses modern OpenGL (shaders). Online
    multiplayer support is included using a Python-based server.
</p>

<div class="embed-responsive embed-responsive-16by9">
    <iframe class="embed-responsive-item" src="//www.youtube.com/embed/tScCneiTGm4?rel=0" allowfullscreen></iframe>
</div>

#### Download

Last Updated: 2014-01-31

<div class="row platforms">
    <div class="col-md-4">
        <a class="thumbnail" href="{{ static('Craft.zip') }}">
            <img src="{{ static('img/platform/windows.png') }}">
            <h3>Windows</h3>
            <h4>Craft.zip (2MB)</h4>
        </a>
    </div>
    <div class="col-md-4">
        <a class="thumbnail" href="https://github.com/fogleman/Craft">
            <img src="{{ static('img/platform/github.png') }}">
            <h3>Source Code</h3>
            <h4>Hosted on GitHub</h4>
        </a>
    </div>
    <div class="col-md-4">
        <a class="thumbnail" href="{{ static('Craft.app.zip') }}">
            <img src="{{ static('img/platform/mac.png') }}">
            <h3>Mac OS X</h3>
            <h4>Craft.app.zip (720 KB)</h4>
        </a>
    </div>
</div>

#### Play Online!

To play online, just launch the app and use the following commands in the game.
Or, you can specify the host and port with command-line arguments. You can play
as a guest but you must register if you want to make changes in the world.
Register for an account at: https://craft.michaelfogleman.com/

##### Commands

    /online HOST [PORT]
    /offline

##### Example

    /online michaelfogleman.com

#### Features

* Simple but nice looking terrain generation using simplex noise.
* More than 10 types of blocks and more can be added easily.
* Supports plants (grass, flowers, trees, etc.) and transparency (glass).
* Simple clouds in the sky (they don't move).
* Day / night cycles and a textured sky dome.
* Signs - you can write text on any block.
* Lights - any block can be set as a light source.
* Ambient occlusion for basic shading of blocks.
* World changes persisted in a sqlite3 database.
* Multiplayer support!

#### Implementation Details

##### Terrain Generation

The terrain is generated using simplex noise - a deterministic noise function
seeded based on position. So the world will always be generated the same way in
a given location.

The world is split up into 32x32 block chunks in the XZ plane (Y is up). This
allows the world to be "infinite" (floating point precision is currently a
problem at large X or Z values) and also makes it easier to manage the data.
Only visible chunks need to be queried from the database.

##### Rendering

Only exposed faces are rendered. This is an important optimization as the vast
majority of blocks are either completely hidden or are only exposing one or
two faces. Each chunk records a one-block width overlap for each neighboring
chunk so it knows which blocks along its perimeter are exposed.

Only visible chunks are rendered. A naive frustum-culling approach is used to
test if a chunk is in the camera's view. If it is not, it is not rendered.
This results in a pretty decent performance improvement as well.

Chunk buffers are completely regenerated when a block is changed in that
chunk, instead of trying to update the VBO.

Text is rendered using a bitmap atlas. Each character is rendered onto two
triangles forming a 2D rectangle.

"Modern" OpenGL is used - no deprecated, fixed-function pipeline functions are
used. Vertex buffer objects are used for position, normal and texture
coordinates. Vertex and fragment shaders are used for rendering. Matrix
manipulation functions are in matrix.c for translation, rotation,
perspective, orthographic, etc. matrices. The 3D models are made up of very
simple primitives - mostly cubes and rectangles. These models are generated
in code in cube.c.

Transparency in glass blocks and plants (plants don't take up the full
rectangular shape of their triangle primitives) is implemented by discarding
magenta-colored pixels in the fragment shader.

##### Database

User changes to the world are stored in a sqlite database. Only the delta is
stored, so the default world is generated and then the user changes are
applied on top when loading.

The main database table is named "block" and has columns p, q, x, y, z, w. (p,
q) identifies the chunk, (x, y, z) identifies the block position and (w)
identifies the block type. 0 represents an empty block (air).

In game, the chunks store their blocks in a hash map. An (x, y, z) key maps to
a (w) value.

The y-position of blocks are limited to 0 &lt;= y &lt; 256. The upper limit is
mainly an artificial limitation to prevent users from building unnecessarily
tall structures. Users are not allowed to destroy blocks at y = 0 to avoid
falling underneath the world.

##### Multiplayer

Multiplayer mode is implemented using plain-old sockets. A simple, ASCII,
line-based protocol is used. Each line is made up of a command code and zero
or more comma-separated arguments. The client requests chunks from the server
with a simple command: C,p,q,key. "C" means "Chunk" and (p, q) identifies the
chunk. The key is used for caching - the server will only send block updates
that have been performed since the client last asked for that chunk. Block
updates (in realtime or as part of a chunk request) are sent to the client in
the format: B,p,q,x,y,z,w. After sending all of the blocks for a requested
chunk, the server will send an updated cache key in the format: K,p,q,key. The
client will store this key and use it the next time it needs to ask for that
chunk. Player positions are sent in the format: P,pid,x,y,z,rx,ry. The pid is
the player ID and the rx and ry values indicate the player's rotation in two
different axes. The client interpolates player positions from the past two
position updates for smoother animation. The client sends its position to the
server at most every 0.1 seconds (less if not moving).

Client-side caching to the sqlite database can be performance intensive when
connecting to a server for the first time. For this reason, sqlite writes are
performed on a background thread. All writes occur in a transaction for
performance. The transaction is committed every 5 seconds as opposed to some
logical amount of work completed. A ring / circular buffer is used as a queue
for what data is to be written to the database.

In multiplayer mode, players can observe one another in the main view or in a
picture-in-picture view. Implementation of the PnP was surprisingly simple -
just change the viewport and render the scene again from the other player's
point of view.

##### Collision Testing

Hit testing (what block the user is pointing at) is implemented by scanning a
ray from the player's position outward, following their sight vector. This is
not a precise method, so the step rate can be made smaller to be more
accurate.

Collision testing simply adjusts the player's position to remain a certain
distance away from any adjacent blocks that are obstacles. (Clouds and plants
are not marked as obstacles, so you pass right through them.)

##### Sky Dome

A textured sky dome is used for the sky. The X-coordinate of the texture
represents time of day. The Y-values map from the bottom of the sky sphere to
the top of the sky sphere. The player is always in the center of the sphere.
The fragment shaders for the blocks also sample the sky texture to determine
the appropriate fog color to blend with based on the block's position relative
to the backing sky.

##### Ambient Occlusion

Ambient occlusion is implemented as described on this page:
http://0fps.wordpress.com/2013/07/03/ambient-occlusion-for-minecraft-like-worlds/

##### Dependencies

* GLEW is used for managing OpenGL extensions across platforms.
* GLFW is used for cross-platform window management.
* lodepng is used for loading PNG textures.
* sqlite3 is used for saving the blocks added / removed by the user.
* tinycthread is used for cross-platform threading.

{% endfilter %}

{% endblock %}
